import heapq


def heuristic_cost_estimate(current, goal):
    return (
        (current[0] - goal[0]) ** 2
        + (current[1] - goal[1]) ** 2
        + (current[2] - goal[2]) ** 2
    ) ** 0.5


def a_star_3d(start, goal, grid):
    open_set = [(0, start)]
    closed_set = set()
    g_score = {start: 0}
    f_score = {start: heuristic_cost_estimate(start, goal)}

    while open_set:
        current_f, current_node = heapq.heappop(open_set)

        if current_node == goal:
            # Reconstruct and return the path if the goal is reached
            path = []
            while current_node in g_score:
                path.append(current_node)
                current_node = g_score[current_node]
            return path[::-1]

        closed_set.add(current_node)

        neighbors = [
            (current_node[0] + i, current_node[1] + j, current_node[2] + k)
            for i in range(-1, 2)
            for j in range(-1, 2)
            for k in range(-1, 2)
            if (i, j, k) != (0, 0, 0)
        ]

        for neighbor in neighbors:
            if neighbor not in grid:
                print(f"Skipping neighbor {neighbor} - not in grid")
                continue

            if grid[neighbor] == "obstacle":
                print(f"Skipping neighbor {neighbor} - obstacle")
                continue

            if neighbor in closed_set:
                print(f"Skipping neighbor {neighbor} - already closed")
                continue

            tentative_g_score = (
                g_score[current_node] + 1
            )  # Assuming each move has a cost of 1

            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic_cost_estimate(
                    neighbor, goal
                )
                heapq.heappush(open_set, (f_score[neighbor], neighbor))

        # Print intermediate steps for debugging
        print("Current Node:", current_node)
        print("Open Set:", open_set)
        print("Closed Set:", closed_set)
        print("-----")

    return None


# Example usage:
start = (0, 0, 0)
goal = (3, 0, 0)

grid = {
    (0, 0, 0): "empty",
    (1, 0, 0): "empty",
    (2, 0, 0): "empty",
    (3, 0, 0): "empty",
    (4, 0, 0): "empty",
    (0, 1, 0): "empty",
    (1, 1, 0): "empty",
    (2, 1, 0): "empty",
    (3, 1, 0): "empty",
    (4, 1, 0): "empty",
    (0, 2, 0): "empty",
    (1, 2, 0): "empty",
    (2, 2, 0): "empty",
    (3, 2, 0): "empty",
    (4, 2, 0): "empty",
    (0, 3, 0): "empty",
    (1, 3, 0): "empty",
    (2, 3, 0): "empty",
    (3, 3, 0): "empty",
    (4, 3, 0): "empty",
    (0, 4, 0): "empty",
    (1, 4, 0): "empty",
    (2, 4, 0): "empty",
    (3, 4, 0): "empty",
    (4, 4, 0): "empty",
}

path = a_star_3d(start, goal, grid)
print("Path:", path)
